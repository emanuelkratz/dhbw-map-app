'use strict';

var core = require('@capacitor/core');

const NativeGeocoder = core.registerPlugin("NativeGeocoder", {
    web: () => Promise.resolve().then(function () { return web; }).then((m) => new m.NativeGeocoderWeb()),
});

const findAC = (address_components, type) => {
    return (address_components.find((component) => component.types.includes(type)) || {
        long_name: "",
        short_name: "",
        types: [],
    });
};
class NativeGeocoderWeb extends core.WebPlugin {
    async reverseGeocode(options) {
        if (!options.apiKey) {
            throw new Error("apiKey is required for web");
        }
        const params = Object.assign(Object.assign({ latlng: `${options.latitude},${options.longitude}`, key: options.apiKey }, (options.defaultLocale && { language: options.defaultLocale })), { result_type: options.resultType || "street_address" });
        return fetch(`https://maps.googleapis.com/maps/api/geocode/json?${new URLSearchParams(params).toString()}`)
            .then((response) => response.json())
            .then((data) => {
            return {
                addresses: data.results
                    .map((result) => {
                    // transform the response in Address[]
                    // use the result from google geocoder and transform it in Address
                    return {
                        latitude: result.geometry.location.lat,
                        longitude: result.geometry.location.lng,
                        countryCode: findAC(result.address_components, "country")
                            .short_name,
                        countryName: findAC(result.address_components, "country")
                            .long_name,
                        postalCode: findAC(result.address_components, "postal_code")
                            .long_name,
                        administrativeArea: findAC(result.address_components, "administrative_area_level_1").long_name,
                        subAdministrativeArea: findAC(result.address_components, "administrative_area_level_2").long_name,
                        locality: findAC(result.address_components, "locality")
                            .long_name,
                        subLocality: findAC(result.address_components, "sublocality")
                            .long_name,
                        thoroughfare: findAC(result.address_components, "route")
                            .long_name,
                        subThoroughfare: findAC(result.address_components, "street_number").long_name,
                        areasOfInterest: [],
                    };
                })
                    .slice(0, options.maxResults || 1),
            };
        });
    }
    async forwardGeocode(options) {
        if (!options.apiKey) {
            throw new Error("apiKey is required for web");
        }
        const params = Object.assign(Object.assign({ address: options.addressString, key: options.apiKey }, (options.defaultLocale && { language: options.defaultLocale })), { result_type: "street_address" });
        return fetch(`https://maps.googleapis.com/maps/api/geocode/json?${new URLSearchParams(params).toString()}`)
            .then((response) => response.json())
            .then((data) => {
            return {
                addresses: data.results
                    .map((result) => {
                    // transform the response in Address[]
                    // use the result from google geocoder and transform it in Address
                    return {
                        latitude: result.geometry.location.lat,
                        longitude: result.geometry.location.lng,
                        countryCode: findAC(result.address_components, "country")
                            .short_name,
                        countryName: findAC(result.address_components, "country")
                            .long_name,
                        postalCode: findAC(result.address_components, "postal_code")
                            .long_name,
                        administrativeArea: findAC(result.address_components, "administrative_area_level_1").long_name,
                        subAdministrativeArea: findAC(result.address_components, "administrative_area_level_2").long_name,
                        locality: findAC(result.address_components, "locality")
                            .long_name,
                        subLocality: findAC(result.address_components, "sublocality")
                            .long_name,
                        thoroughfare: findAC(result.address_components, "route")
                            .long_name,
                        subThoroughfare: findAC(result.address_components, "street_number").long_name,
                        areasOfInterest: [],
                    };
                })
                    .slice(0, options.maxResults || 1),
            };
        });
    }
}

var web = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NativeGeocoderWeb: NativeGeocoderWeb
});

exports.NativeGeocoder = NativeGeocoder;
//# sourceMappingURL=plugin.cjs.js.map
